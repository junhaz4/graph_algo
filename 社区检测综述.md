# 社区检测算法综述（community detection）

## 社区检测

社区检测（community detection）又被称为是社区发现，它是用来揭示网络聚集行为的一种技术。社区检测实际就是一种网络聚类的方法，这里的“社区”，我们可以将其理解为一类具有相同特性的节点的集合。

社区检测算法的一个关键作用在于可用于从网络中提取有用的信息。 社区检测面临的最大挑战是社区结构没有普遍定义（与和聚类类似，没标签，无法直接评价效果的好坏）。

**社区的本质**

社区的节点间是网络拓朴结构，即节点间是存在拓朴连接结构的，我们不能将其和欧式空间或者P空间中的点向量集合空间混为一谈。

以欧式空间为例，不同的节点向量存在于不同的空间位置中，向量夹角近的点向量彼此距离近，而向量夹角远的向量彼此距离远。但是即使是欧式距离很近的向量点，也不一定就代表这它们之间存在拓朴连接关系，只能说在一定的度量下（例如欧式距离度量），这两个节点很相近。

但是在社区结构中，节点之间没有什么空间位置的概念。相对的，节点间存在的是一种逻辑拓朴结构，即存在一种共有关系。

存在共有关系的节点在逻辑上会聚集为一个社区，而社区之前不存在或者存在很弱的共有关系，则呈现分离的逻辑拓朴结构。

一定要注意不要用空间结构的概念来试图理解社区结构，不然会陷入理解的困境，社区中的节点只是因为逻辑上的共有关系而聚集在一起而已，彼此之间的位置也没有实际意义，而社区族群之间的分离也是表达一种逻辑上的弱共有关系。

举一些实际的例子：

1. 节点代表消费者：节点间的连接代表了它们共同购买了一批书籍，weight代表共同购买的书籍数；
2. 节点代表DNS域名：节点间的连接代表了它们拥有一批共同的src client ip（客户端），weight代表了共同的src_ip数量；

**为什么要社区检测？**

1. 在分析不同的网络时，发现其中的社区可能很重要。

2. 社区检测技术对于社交媒体算法很有用，可以发现具有共同兴趣的人并保持他们紧密联系。

3. 社区检测可用于机器学习中，以检测具有相似属性的组并出于各种原因提取组。例如，该技术可用于发现社交网络或股票市场中的操纵群体。

**社区检测与聚类的对比分析**

1. 聚类是一种机器学习技术，其中相似的数据点根据它们的属性被分组到同一个簇中。尽管聚类可以应用于网络，但它是无监督机器学习中一个更广泛的领域，可以处理多种属性类型。聚类算法倾向于将单个外围节点与其应属于的社区分开。
2. 社区检测是专门为网络分析量身定制的，网络分析依赖于称为边的单一属性类型。

社区检测类似于聚类，但是，聚类和社区检测技术都可以应用于许多网络分析问题，并且可能会根据领域产生不同的优缺点。

**什么时候使用社区检测**

```
(Newman and Gievan 2004) A community is a subgraph containing nodes which are more dense ly linked to each other than to the rest of the graph or equivalently, a graph has a community structure if the number of links into any subgraph is higher than the number of links between those subgraphs.
```

即我们需要先确定要解决的业务场景中，存在明显的聚集规律，节点（可以是抽象的）之间形成一定的族群结构，而不是呈现无规律的随机分散。同时另一方面，这种聚集的结构是“有意义的”，这里所谓的有意义是指这种聚集本身可以翻译为一定的上层业务场景的表现。

但是很多时候，我们业务场景中的数据集之间的共有关系并不是表现的很明显，即节点之间互相都或多或少存在一些共有关系，这样直接进行社区发现效果肯定是不好的。

所以一个很重要点是，我们在进行社区发现之前，一定要进行数据降噪。

理想情况下，降噪后得到的数据集已经是社区完全内聚，社区间完全零连接，这样pylouvain只要一轮运行就直接得到结果。当然实际场景中不可能有这么好的情况，数据源质量，专家经验的丰富程度等等都会影响降噪的效果，一般情况下，降噪只要能cutoff 90%以上的噪音，pylouvain就基本能通过几轮的迭代完成整体的社区发现过程。

**衡量指标** 

模块度（Modularity）是一种评估网络中社区划分质量的指标，它衡量的是社区内部边相对于社区外部边的相对密度。模块度的值范围在【-0.5,1），模块度在 0.3 到 0.7 之间表示较好的社区划分。

计算模块度时，会比较实际社区内边的权重之和与随机情况下预期的边权重之和，以判断社区划分是否优于随机分布。
 
注意，直接最大化一个网络的模块度是NP-hard问题，但是可以通过贪心策略近似求解。

$$ Q = \frac{1}{2m} \sum_{i,j}[A_{i,j}-\frac{k_{i}k_{j}}{2m}]\delta(c_{i},c_{j})$$ 
其中
- $A_{i,j}$ 是实际网络中节点 $i$ 和 $j$ 之间的边权重(1表示有连接，0表示无连接)
- $k_{i}$ 是节点 $i$ 的度数
- $c_{i}$ 是节点 $i$ 所属的社区，$\delta(c_{i},c_{j})$ 是 Kronecker delta 函数，当$c_{i}$和$c_{j}$在同一个社区时为1，否则为0
- $m$ 是网络的边总数
  
在一个完全封闭的社区中（即所有节点都互相内部连接，但是不和社区外部其他节点有连接，所有的边都在社区内部），因此模块度的贡献最大，接近于 1。

证明：
$$ Q = \frac{1}{2m} \sum_{i,j}[A_{i,j}-\frac{k_{i}k_{j}}{2m}]\delta(c_{i},c_{j}) = \frac{1}{2m} \sum_{i,j}(e_{ij}-\frac{k^{2}_{i}}{2m})$$ 

其中： 
 -  $e_{ij}$是社区内部的边数量（在完全封闭的社区中，$e_{ij}$ 的值为$\frac{n(n-1)}{2}$）
 -  $k_{i}$是社区节点的总度数 （在完全封闭的社区中，$e_{ij}$ 的值为$n(n-1)$）
 -  m是社区内部的边总数
 -  带入计算最终得到 $Q=1$

举例说明：
假设我们有一个社区 C,包含 3 个节点：A、B、C。它们形成一个完全图，即每对节点之间都有一条边。总共有 3 条边：A-B, B-C, A-C。
1. 计算边数，m=3
2. 计算每个节点的度数k，每个节点（A、B、C）的度数都是 2，因为每个节点都连接到其他两个节点。
3. 计算每对节点的贡献
    - 对于A-B：$A_{ij}=1,k_{A}=2,k_{B}=2$， 贡献=1-$\frac{2*2}{2*3}$ = $\frac{1}{3}$
    - 对于B-C：$A_{ij}=1,k_{B}=2,k_{C}=2$， 贡献=1-$\frac{2*2}{2*3}$ = $\frac{1}{3}$
    - 对于A-C：$A_{ij}=1,k_{A}=2,k_{C}=2$， 贡献=1-$\frac{2*2}{2*3}$ = $\frac{1}{3}$
    - 总和为：$\frac{1}{3}+\frac{1}{3}+\frac{1}{3}=1$
4. 计算模块度：$Q=\frac{1}{2*3}*1 = \frac{1}{6}$

为什么不是1？
因为我们计算的是实际的社区内部边相对于社区外部边的相对密度，模块度为1的情况通常是理想化的，表示社区结构与随机网络相比有最大的差异

## 社区发现算法的分类

### 传统的社区检测技术

#### 图分割
将图划分为预定义大小的g个簇（子图），使得簇中的边数比簇之间的边数更密集。图划分技术的著名例子是谱二分法和Kernighan-Lin算法（kl算法）；在cluster gcn中，google使用了metis和craclus来做graph的partition。

#### 聚类
图上的聚类算法其实可以看作常规的表格数据的聚类算法，因为图可以表示为其邻接矩阵或经过矩阵分解转化等降维之后的小矩阵，然后使用常规的聚类算法进行聚类。

##### 分层聚类
分层聚类算法中，认为一个图就是一个大社区，这个大社区包含复杂的层次结构，即社区可能是不同级别的小社区的集合。在这种情况下，可以使用分层聚类技术来识别图的多级社区结构。

分层聚类技术基于顶点相似性度量（例如jaccard，dasgupta score）。他们不需要预定义的社区规模和数量。它们可以用树状图更好地表示。

分层聚类技术可分为两类：

- 凝聚聚类：这是一种自下而上的技术，因为在开始时，它将每个节点视为一个单独的集群，并基于高度相似性迭代合并它们，最终形成唯一的社区，例如基于linkage的paris算法。

- 分裂聚类：这是一种自上而下的技术，因为在开始时，它将整个网络视为一个集群，并通过消除连接低相似度节点的边来迭代地将其分割，最终形成独特的社区。

##### 划分聚类
将数据集划分为预定义数量的k个非重叠聚类。目标是将数据点划分为k个簇，以便基于节点之间的不相似性度量最小化/最大化代价函数。一些常用的成本函数是最小k-中值、k-聚类和、k-聚类和k-中心。分区聚类技术的示例包括k-均值聚类和模糊k-均值聚类。注意，在模糊k-均值聚类中，一个节点可能属于多个聚类。

##### 谱聚类
谱聚类包括使用矩阵特征向量，根据数据点之间的成对相似性划分数据点集的所有技术。示例包括费德勒和多纳思的拉普拉斯谱划分方法。

### 基于分裂的社区检测技术
这种方法基于低相似性删除网络中的簇间的边，从而将社区彼此分离。这种类型的主要示例包括GN算法，分裂算法和分裂聚类的思想比较相似，只不过前者是直接在图上进行边的切边，而后者则是基于节点表征向量的相似度进行节点自下而上的合并实现的。

### 基于模块化优化的社区检测技术

#### 贪心法
- newman 贪婪搜索法

纽曼贪婪搜索算法是第一个提出的模块化优化算法。这是一种聚合技术，最初，每个节点属于一个不同的模块，然后根据模块度增益迭代合并。它在稀疏网络上的时间复杂度为O($n^{3}$)。

- fast newman 贪婪搜索法

这是纽曼算法的快速版本，由高效的数据结构实现。它在稀疏网络上的计算复杂度为O(nlog2n)

- louvain

Louvain是一种启发式贪婪算法，用于在复杂加权图中发现社群。它也是基于模块化优化。它为每个顶点指定不同的社区；每个顶点一个。它根据模块化的增益迭代地合并节点。若没有增益，那么这个节点将保留在它自己的社区中。重复该过程，直到模块度增益不再增加。然后，它以超级节点取代第一阶段确定的社区的方式重建网络继续第二阶段的迭代计算。。。依此类推 。其时间复杂度为O（nlogn）。

#### 模拟退火
这是用于给定目标函数进行全局优化的离散随机方法。Guimer`a等人使用了基于模拟退火的模块化优化方法。最初，它将网络分解为随机分区。优化基于局部和全局移动。局部移动基于模块化增益将节点从一个分区随机移动到另一个分区。全局移动包括分区的拆分和合并。

#### 极值优化
Boettcher等人设计了极值优化，作为物理和组合优化问题的通用启发式搜索技术。该算法的精度可与遗传算法和模拟退火算法相媲美。它着重于局部变量的优化。Duch等人将其用于模块化优化。它将适应度分配给每个节点；适应度值是通过节点的局部模性与其度的比值获得的。它在单个配置中演化出单个解决方案，并进行局部修改。它首先将网络随机划分为两个相同顺序的分区。它迭代地将适应度最低的顶点移动到其他分区。移位后，分区会发生变化，因此它会重新计算许多节点的局部适应度。该过程重复进行，直到达到全局模块化的最佳值。

#### 谱优化
谱优化是指使用模块化矩阵的特征向量和特征值来进行模块化优化，这种优化相当快。

#### 进化算法
进化算法是一类基于人工智能的元启发式优化算法。他们以其有效的本地学习和全局搜索能力而闻名。基于单目标优化和多目标优化，这些方法大致分为两类。第一类的例子包括MAGA网络等，第二类的例子包括MOEA/D等。

### 重叠社区检测技术
在实际网络中，大多数节点可能同时属于多个社区。传统的社区检测技术无法识别重叠的社区。Clique percolation 是用于识别网络中重叠社区的最著名技术。它基于这样一种观点，即cliques更可能由紧密连接的内部边形成，而不是由稀疏连接的外部边形成。社区由k-cliques 组成，k-cliques 指的是具有k个顶点的完整子图。如果两个clique共享k-1个节点，则认为它们相邻。k-cliques社区是由所有相邻的k-clique组成的。该类别的其他示例包括top graph clusters、SVINET和标签传播算法。

### 动态社区检测算法
这些技术在图随着时间流逝的过程中动态更新顶点的社区划分
- Potts模型（自旋模型）
  
Potts模型是统计物理学中使用的著名模型之一。它展示了一个自旋系统，它可以处于q个不同的状态。相邻自旋之间的相互作用可能是铁磁或反铁磁的。Potts自旋变量可以映射到具有社区结构的图的节点。从相邻自旋之间的相互作用来看，社区结构可以从系统的类似值自旋簇中识别出来，因为社区内的相互作用更多，社区外的相互作用更少。受此启发，Reichardt等人提出了一种基于q-Potts模型的社区检测技术，该模型考虑了近邻之间的相互作用。

- 随机游走

采用随机游走来识别社区。在随机行走中，步行者从一个节点开始在社区内行走，并在每个时间步移动到随机均匀选择的相邻节点。由于高密度和多条路径，步行者在密集的社区内花费了很长时间。基于随机游动的最流行技术的例子有PageRank算法、WalkTrap和Infomap。

- 扩散社区

复杂网络中的扩散社区是一组节点，通过网络中相同属性、行为或信息的传播而组合在一起，这一类别的例子包括标签传播和动态节点着色

- 同步

同步是一种新兴的现象，受到了不同领域的关注。它发生在相互作用的单元中。在同步状态下，系统单元随时间保持相同或相似的状态。同步还用于网络中的社区检测。如果振荡器位于具有随机初始相位的节点处，并且与最近的邻居相互作用，则属于同一分区的振荡器首先同步，而完全同步需要较长的时间。因此，如果遵循该过程的演化时间，则具有同步节点群的状态可以非常稳定和延长，因此可以容易地识别。

## 常见算法

### 鲁汶算法(Louvain )

### 莱顿社区检测(Leiden)

### 标签传播算法(Label propagation algorithm)

### infoMap算法

### 强连接组件(Strongly Connected Components)

### 三角形计数(Triangle Count)

### 局部聚类系数(Local Clustering Coefficient)

